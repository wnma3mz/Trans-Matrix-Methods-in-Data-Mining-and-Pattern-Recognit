第十五章

计算特征值和奇异值

在Matlab和其他现代编程环境中，特征值和奇异值是使用高级函数获得的，例如，eig（a）和svd（a）。这些函数实现来自lapack子程序库[1]的算法。为了确定高阶函数背后的方向，在本章中，我们简要介绍了计算稠密矩阵和大稀疏矩阵特征值和奇异值的一些方法。有关更广泛的治疗，请参见例如[4，42，79]。

函数eig和svd用于密集矩阵，即大多数元素为非零的矩阵。稠密矩阵的特征值算法有两个阶段：

\1.    矩阵简化为紧致形式：对称情况下的三对角矩阵和非对称情况下的海森堡矩阵。这个相位由有限的正交变换序列组成。

\2.    迭代还原为对角形式（对称情况）或三角形形式（非对称情况）。这是使用QR算法完成的。

对于大型稀疏矩阵，通常不可能（甚至有趣）计算所有特征值。这里有一些利用稀疏性的特殊方法。利用特征值算法的变化来计算奇异值。

作为背景材料，我们给出了关于特征值问题摄动理论的一些理论结果。此外，本文还简要介绍了计算特征值的幂次法及其相应的逆迭代法。

在线性代数教材中，常把矩阵a∈rn×n的特征值问题作为多项式方程的解引入。

Det（a−λi）=0。

在一般问题的计算解中，这种方法是无用的，有两个原因：（1）对于有意义的维数矩阵，计算行列式太昂贵；（2）即使行列式和多项式可以计算，特征值对pertu非常敏感。系数中的

一百七十九

多项式。相反，特征值数值计算的基本工具是正交相似变换。设V为正交矩阵。然后进行转换（对应于基础的更改）

A−→V TAV（15.1）

很明显，在这种变换下，特征值是保留的：

ax=λx v tav y=λy，（15.2）

其中y=v tx。

15.1扰动理论

计算特征值的QR算法基于正交相似变换（15.1），它计算一系列变换，最终结果是对角线（对于对称A）或三角形（对于非对称A）。由于该算法是迭代的，因此有必要确定浮点数何时足够小，以便在数值上被视为零。为了有一个良好的理论基础，这一决定，必须知道特征值和特征向量对数据的小扰动，即矩阵系数有多敏感。

关于特征值和奇异值灵敏度的知识也很有用，这是一个更基本的原因：矩阵元素通常是测量值，容易出错。灵敏度理论给出了在这种情况下我们能信任特征值等的信息。

在这一节中，我们给出了一些没有证明的摄动结果，首先对对称矩阵a∈rn×n，假设n×n矩阵的特征值为

命令

λ1≥λ2≥·······≥λn。

我们考虑一个扰动矩阵a+e，并询问a+e的特征值和特征向量与a的特征值和特征向量之间的距离。

### 例15.1。让

.

这是三对角矩阵QR算法的一个典型情况：通过一系列正交相似变换，使三对角矩阵收敛到一个对角矩阵。我们什么时候可以考虑一个小的非对角浮点数为零？A和A+E的特征值能偏离多少？

15.1.扰动理论

定理15.2。设a∈rn×n和a+e为对称矩阵。则λk（a）+λn（e）≤λk（a+e）≤λk（a）+λ1（e），k=1,2，…，n，

和

​                                                  

从这个定理我们可以看出，不严格地说，如果我们用扰动矩阵元素，那么特征值也会受到扰动）。例如，在示例15.1中，矩阵e的特征值为±10-15和。因此，两个矩阵的特征值最多相差10-15。

特征向量的灵敏度取决于特征值的分离。

定理15.3。设[λ，q]为对称矩阵A的特征值特征向量对，假设特征值简单。形成正交矩阵并对矩阵qtaq和qteq进行划分，

.

定义

   

然后假设。然后存在a+e的特征向量q_，这样q和q_之间的距离（测量为矢量之间角度的正弦）是有界的：

.

这个定理只有在特征值简单的情况下才有意义。结果表明，特征值相近的特征向量对扰动较为敏感，计算精度较高。

例15.4。例15.1中矩阵A的特征值为

0.8820、1.0000、2.0000、3.1180。

与最小特征值相对应的A和A+E的特征向量之间的偏差可通过以下公式估计：

.

由于特征值被很好地分离，因此该矩阵的特征向量对数据中的扰动相当不敏感。

为了给出非对称矩阵的摄动结果，我们首先引入了上拟三角矩阵的概念：如果上拟三角矩阵的形式为

，

其中，每个RII要么是一个标量，要么是一个具有复共轭特征值的2×2矩阵。R的特征值等于对角块Rii的特征值（也就是说，如果Rii是一个标量，那么它就是R的特征值）。

定理15.5（实舒尔分解）。对于任意（对称或非对称）矩阵a∈rn×n，存在一个正交矩阵u，使得

Utau=R，（15.3）

其中R是上准三角形。

分区

，

其中Uk∈Rn×K和Rk∈Rk×K，从（15.3）我们得到

AUK=乌克兰（15.4）

这意味着r（auk）r（uk），其中r（uk）表示英国的范围。因此，UK被称为a的不变子空间或特征空间，分解（15.4）被称为局部舒尔分解。

如果a是对称的，那么r是对角的，schur分解与特征值分解utau=d相同，其中d是对角的。如果A是非对称的，那么它的部分或全部特征值可能是复杂的。

例15.6。舒尔分解是matlab中的标准函数。如果矩阵是实数，则r是上准三角形：

\>>A=兰登（3）

   

\>>[U，R]=舒尔（A）

U=0.2827 0.2924 0.9136

0.8191-0.5691-0.0713-0.4991-0.7685 0.4004

15.1.扰动理论

R=-1.6984 0.2644-1.2548 0 0.2233 0.7223

0-1.4713 0.2233

如果我们计算特征值分解，我们得到

\>>[X，D]=EIG（A）

| X=0.2827     | 0.4094-0.3992i   0.4094+0.3992i |
| ------------ | ------------------------------- |
| 零点八一九一 | -0.0950+0.5569i-0.0950-0.5569i  |
| -0.4991美元  | 0.5948   0.5948                 |
| D=-1.6984    | 0 0                             |
| 零           | 0.2233+1.0309i   0              |
| 零           | 0 0.2233-1.0309i                |

非对称矩阵的特征向量不是正交的。

非对称矩阵特征值的灵敏度取决于舒尔分解中严格上三角部分R的范数。为了方便起见，我们这里使用复杂版本的装饰来表示结果。-

位置。

定理15.7。设uhau=r=d+n为a的复Schur分解，其中u为单位，r为上三角，d为对角，τ表示扰动矩阵a+e的特征值。此外，设p为最小整数，使得np=0。然后

，

哪里

.

该定理表明，高度非对称矩阵的特征值比对称矩阵的特征值对扰动更为敏感；参见定理15.2。例15.8。矩阵

   

具有特征值

2，2，2，

和

分别为2.00031622776602、1.99968377223398、2.0000000000000。扰动的相关量为η1/2≈3.164·10−04。

定理15.3的非对称版本是相似的：特征向量之间的角度又取决于特征值的分离。我们在下面给出了一个简化的陈述，我们忽略了复杂特征值的可能性。

定理15.9。设[λ，q]为a的特征值特征向量对，并假定该特征值是简单的。形成正交矩阵和划分

矩阵

.

定义

假设d>0。如果扰动e足够小，则存在a+e的特征向量q_，以向量之间角度的正弦测量的q和q_之间的距离受

.

这个定理本质上说，如果我们扰动，那么特征向量就受到/d的扰动。

例15.10。将三对角矩阵定义为

.

对于n=100，其最小特征值约为0.01098771。以下matlab脚本计算定理15.9中的数量d：

%xn是对应于

%最小特征值

[q，r]=qr（xn）；

h=q'*a*q；lam=h（1,1）；a2=h（2:n，2:n）；

d=最小值（svd（a2 lam*眼（尺寸（a2）））；

我们得到d=1.6207·10−4。因此，如果我们将矩阵扰动10-10，这可能会使特征向量大约改变4·10-6。

15.2.幂法和逆迭代

15.2幂法和逆迭代

幂法是计算最大特征值和相应特征向量的经典迭代方法。它的收敛速度很慢，这取决于特征值的分布。因此，它不应该用于密集矩阵。对于稀疏矩阵，通常应使用Lanczos方法或Jacobi–Davidson方法的变体；见[4]和第15.8.3节。然而，在某些应用中，问题的维度是如此之大，以至于没有其他方法是可行的；见第12章。

尽管在实际问题上的实用性有限，但从理论上讲，幂法是很重要的。此外，还有一种变幂法，逆迭代，这是非常重要的现实意义。

在这一节中，我们给出了比第12章更一般的幂法公式，并回顾了它的一些性质。

### 计算最大特征值的幂法

%k=1的初始近似值x：最大y=a*x；lambda=y'*x；如果范数（y-lambda*x）<tol*abs（lambda）

break%停止迭代结束x=1/norm（y）*y；

结束

​             

幂法的收敛性取决于矩阵A特征值的分布，假设最大特征值的大小是简单的，且λi是有序的λ1>λ2≥····≥λn。收敛速度由比值λ2/λ1确定。如果这个比率接近1，那么迭代就非常慢。

根据特征值问题的残差向量，可以建立幂次迭代的停止准则：如果残差r=a x_−λ_x_的范数很小，则特征值近似较好。

例15.11。再考虑一下三对角矩阵

.

A20的两个最大特征值约为3.9677和3.9016。作为初始近似，我们选择了一个随机向量。在图15.1中，我们绘制了迭代期间的不同错误度量：相对残差表示

零

   

图15.1.A20的功率迭代。相对残差

（实线），特征值近似中的绝对误差（破折号-

虚线），以及精确特征向量和近似值（虚线）之间的角度（弧度）。

第k次迭代中的λ1近似值）、特征值近似值的误差以及精确和近似特征向量之间的角度。经过150次迭代后，计算出的特征值近似值的相对误差为0.0032。

我们得到λ2（a20）/λ1（a20）=0.9833。接下来是

0.9833150≈0.0802，

这表明收敛非常慢，如图15.1所示。这与150次迭代期间精确和近似特征向量之间的角度减小相当：从1.2847弧度到0.0306弧度。

如果我们用幂法中的−1迭代，

X（K）=A−1X（K−1）、

然后，由于a−1的特征值为1/λi，特征值近似序列收敛到1/λmin，其中λmin是最小绝对值的特征值。更好的是，如果我们有足够好的特征值之一τ≈λk的近似值，那么移位矩阵a−τi的特征值最小。因此，“逆幂法”的收敛速度很快，这种方法称为逆迭代。

15.3.三对角形式的相似性减少

​                     



​        









%初始近似x和特征值近似tau

[l，u]=lu（a-tau*i）；k=1时：max y=u（l\x）；theta=y'*x；if norm（y-theta*x）<tol*abs（theta）

break%停止迭代结束x=1/norm（y）*y；

结束

lambda=tau+1/theta；x=1/norm（y）*y；

​             

例15.12。实施例15.10中矩阵A100的最小特征值为λ100=0.01098771187192至14位小数精度。如果我们使用近似值λ100≈τ=0.011并应用逆迭代，我们得到快速收敛；见图15.2。在这个例子中，收敛因子是

，

这意味着经过四次迭代后，误差减小了3·10−10的系数。

为了提高效率，逆迭代要求我们有很好的特征值近似。此外，我们必须能够廉价地求解线性系统（a−τi）y=x（对于y）。如果A是带矩阵，那么可以很容易地得到LU分解，并且在每次迭代中，可以通过前向替换和后向替换（如上面的代码所示）来求解系统。如果可以计算稀疏LU分解而不需要太多填充，那么其他稀疏矩阵也可以使用相同的方法。

15.3三对角形式的相似性降低

我们将在第15.4节中介绍的QR算法是一种迭代算法，其中在每个步骤中都会计算一个QR分解。如果将其应用于稠密矩阵a∈rn×n，则阶跃成本为o（n3）。通过首先将矩阵变换为紧凑形式，通过正交相似变换（15.1），可以大大降低这种高昂的成本。

A-→V TAV，

对于正交矩阵V。我们已经在（15.2）中看到了特征值在这种变换下是保持不变的，

ax=λx v tav y=λy，

其中y=v tx。

​                                                     



​     

​     



​     

​     



​     

​     



​     

​     



​     

​     



​     

​     



​     

​     





​     

​     

​     





​     

​     

​     





​     

​     

​     





​     

​     

​     





​     

​     

​     





​     

​     

​     





​     

​     

​     

​     

​     

​     

​     











图15.2.a10的逆迭代，τ=0.011。相对残差（实线）、特征值近似（虚线）中的绝对误差以及精确特征向量和近似（虚线）之间的角度（弧度）。

它可以简化为三对角形式。我们用一个例子来说明这个过程，让a∈rn×n是对称的。通过一系列的户主转变

n=6。首先，当我们从左乘a时，我们构造一个从第1列位置3到n的元素归零的变换：a=h1_××××××___=____×0000××××___

××××××

h1___××××××_。

××××××

××××××

××××××

在转换中更改的元素由第一行的元素表示，不会更改。在正交相似变换中。注意，

我们将乘以从右边转置的同一矩阵。因为在左乘法中，第一行没有被触摸，所以第一列将保持不变：

.


 

由于对称性，第一行的元素3到n等于零。

在下一步中，我们将第二列中位置4到N的元素归零。因为这只影响第3行到第n行以及相应的列，所以这不会破坏我们在第一步中创建的零。结果是

.

在n-2这样的相似变换之后，矩阵是三对角形式：

| _×0   T× | ×   ×   × | 零   ×   × | 零   零   × | 0 0   零 | 0_   0 0 |
| -------- | --------- | ---------- | ----------- | -------- | -------- |
|          |           |            |             |          |          |

V av=，

000 000×0×0×0×0×0×0_

0倍

其中v=h1th2t···································

总之，我们已经演示了如何通过N-2户主转换序列将对称矩阵简化为三对角形式：

a−→t=v tav，v=h1h2···hn−2，（15.5）

由于三对角矩阵T是通过相似变换进行约简的，所以它具有与A相同的特征值。

如果要利用对称性，将其简化为三对角形式需要4n3/3个触发器。在QR分解的情况下，户主转换可以存储在A的次极化部分。如果显式计算V，则需要4n3/3额外的触发器。

15.4对称三对角的QR算法

### 矩阵

现在我们将给出对称三对角矩阵的QR算法的草图。我们强调，我们的matlab代码被大大简化，仅用于演示算法的基本思想。实际软件（在LAPACK中）包含许多效率、鲁棒性和数值稳定性方面的特性。

我们所描述的过程可以看作是相似性约简（15.5）的延续，但现在我们将矩阵t简化为对角形式：

t−→=qttq，q=q1q2···（15.6）

式中∧=diag（λ1λ2…，λn）。矩阵qi将是正交的，但在这里它们将使用平面旋转来构造。然而，（15.5）和（15.6）之间最重要的区别是没有计算∧的有限算法。我们计算矩阵序列，

t0：=t，t i=qti−1qi，i=1,2，…（15.7）

这样它就收敛到一个对角矩阵，

lim ti=∧。

I→∞

我们将在数值例子中证明收敛速度非常快，因此在浮点运算中，算法实际上可以被视为有限的。由于（15.7）中的所有变换都是相似变换，因此∧的对角元素是t的特征值。

我们现在给出对称三对角矩阵t∈rn×n的qr算法的第一版。

对称t的qr迭代：底部特征值

对于i=1：最大百分比临时简化

mu=wilkshift（t（n-1:n，n-1:n））；[q，r]=qr（t-mu*i）；

t=r*q+mu*i端

函数mu=wilkshift（t）；%计算wilkinson shift l=eig（t）；如果abs（l（1）-t（2,2））<abs（l（2）-t（2,2））

mu=l（1）；否则mu=l（2）；

结束

​             

我们看到移位矩阵qr=t−τi的qr分解被计算出来，然后将移位加回t：=rq+τi。移位是右下角最接近tnn的2×2子矩阵的特征值。这叫做威尔金森变换。

我们把算法应用于矩阵

（15.8）

在第一步之后，结果被（为了可读性稍微编辑了一下）

t=1.0000 0.7071 0 0 0 0 0

0.7071 2.0000 1.2247 0 0 0 0 1.2247 2.3333-0.9428 0 0 0-0.9428 1.6667 0.8660 0

0 0 0 0.8660 2.0000-0.5000

0 0 0 0-0.5000 3.0000

我们首先看到三角形结构被保留下来，右下角的非对角元素变小了。我们还执行了三个步骤，并更仔细地观察了该子矩阵：

2.36530292572181-0.02609619264716

| -0.02609619264716  | 3.24632297453998   |
| ------------------ | ------------------ |
| 2.59270689576885   | 0.00000366571479号 |
| 0.00000366571479号 | 3.24697960370634号 |
| 2.77097818052654   | 0.00000亿          |
| -0.00000亿         | 3.24697960371747   |

因此，经过四次迭代后，非对角元素的工作精度变为零，因此我们在右下角有一个特征值。

当特征值被发现后，我们可以消除这个问题，继续使用上面的（n-1）×（n-1）子矩阵，它现在是

| 零点四三七四 | 零点三一七六 | 零           | 零           | 零           |
| ------------ | ------------ | ------------ | ------------ | ------------ |
| 零点三一七六 | 零点七九六一 | -0.4395美元  | 零           | 零           |
| 零           | -0.4395美元  | 一点三一九八 | 零点二九二二 | 零           |
| 零           | 零           | 零点二九二二 | 三点四二八八 | 零点五九零二 |
| 零           | 零           | 零           | 零点五九零二 | 二点七七一零 |

我们现在对这个矩阵应用相同的算法。在接下来的三个步骤中跟踪它的右下子矩阵

3.74629910763238-0.01184028941948

| -0.01184028941948 | 2.44513898239641  |
| ----------------- | ----------------- |
| 3.68352336882524  | 0.0000009405188元 |
| 0.0000009405188元 | 2.44504186791263  |
| 3.54823766699472  | 0.00000亿         |
| -0.00000亿        | 2.44504186791263  |

在这三次迭代之后，我们又在右下角有了一个特征值。现在，该算法通过将该特征值缩减并将活动矩阵的维数减少一个来进行计算。下面给出了该算法的初步实现。

​                     





​        









函数[d，it]=qrtrid（t）；

%计算对称三对角的特征值

%矩阵采用二维显式算法

%威尔金森位移n=尺寸（t，1）；it=0；对于i=n:-1:3

而abs（t（i-1，i））>…

（abs（t（i，i））+abs（t（i-1，i-1））*c*eps it=it+1；mu=wilkshift（t（i-1:i，i-1:i））；[q，r]=qr（t（1:i，1:i）-mu*眼（i））；

t=r*q+mu*眼（i）；末端d（i）=t（i，i）；末端d（1:2）=eig（t（1:2,1:2））'；

​             

对于给定的子矩阵t（1:i，1:i），qr步数迭代到停止标准

   

满足，其中c是一个小常数，μ是单位四舍五入。从定理15.2我们可以看出，考虑到这样一个小元素作为一个数值零，会导致特征值的扰动非常小（并且可以接受）。在实际软件中，使用了稍微复杂一点的停止标准。

当应用于矩阵t100（参见（15.8））时，值为c=5204 qr步骤，即每个特征值约2步。计算的特征值与Matlab特征值函数计算的最大偏差为2.9·10−15。

当然，使用matlab函数qr来计算三对角矩阵的qr分解是一种效率很低的方法，qr是一种基于户主的算法。相反，应使用O（N）触发器中的n-1平面旋转计算分解。我们用一个小例子来说明这个过程，其中三对角矩阵t=t（0）是6×6。（1,2）平面中的第一个子垂线元素（从顶部）通过从左侧旋转归零，然后第二个子垂线通过（2,3）中的旋转归零。象征性地，

.

注意创建的填充（新的非零元素，表示为+）。在n-1步之后，我们得到一个具有三个非零对角线的上三角矩阵：

| =GTN 1 GT1（t（0）×0   R−····−τi）= | ×   ×0 | +   ×   ×0 | +   ×   ×0 | +   ×   ×0 | ××+。 |
| ----------------------------------- | ------ | ---------- | ---------- | ---------- | ----- |
|                                     |        |            |            |            |       |

然后，我们应用右旋，rg1······gn-1，即，我们从涉及前两列的转换开始。然后进行涉及第二列和第三列的旋转。两步之后的结果是

.

我们看到，在从左到右的变换中，我们在对角线下面引入的零被系统地填充了。经过n-1步后，我们

.

但是我们做了一个相似变换：当q=g1g2······································

（1）t（0）t（0）

| t=rq+τi=q（t−τi）q+τi=q t q，   所以我们知道t（1）是对称的，   ××____   （1）=××   T×××。   ×××。   ×××。   ××   因此，我们显示了以下结果。 | （15.9） |
| ------------------------------------------------------------ | -------- |
|                                                              |          |

提案15.13。三对角矩阵的qr步骤

qr=t（k）−τki，t（k+1）=rq+τki，

是相似变换

t（k+1）=qtt（k）q，（15.10）

保留了三对角结构。转换可以用O（N）触发器中的平面旋转来计算。

从（15.9）可以看出，这种转变似乎不起重要作用。然而，它决定了QR步骤中正交变换的值。实际上，移位策略对于算法的有效性是绝对必要的：如果不执行移位，那么QR算法通常会非常缓慢地收敛，实际上与幂法一样缓慢；参见第15.2节。另一方面，可以证明[107]（如[93，第3章]）移位的QR算法具有很快的收敛性。

提案15.14.具有威尔金森位移的对称QR算法三次收敛于特征值分解。

在QR算法的实际软件中，我们上面概述的算法有几个改进。例如，算法检查所有的非对角元素（如果它们很小）：当发现一个可以忽略的非对角元素时，问题可以分为两部分。QR算法还有一个分而治之的变体。关于广泛治疗，见[42，第8章]。

15.4.1隐性转变

QR算法的一个重要方面是移位可以隐式执行。这对于该算法在支持向量机和非对称特征问题中的应用尤其有用。这个变量是基于隐式Q定理的，我们在这里用稍微简化的形式给出。

定理15.15。假设a是对称的，假设q和v是正交矩阵，qtaq和v tav都是三对角矩阵。那么，如果q和v的第一列相等，q1=v1，那么q和v基本上相等：q i=±vi，i=2,3，…，n。

有关证据，请参见[42，第8章]。

这个定理的一个结果是，如果我们在t−τi的qr分解中确定并应用第一个转换，并且如果我们以这样一种方式构造其余的转换，我们最终得到一个三对角矩阵，那么我们已经执行了一个移位的qr步骤，正如在命题中一样。15.13.本程序执行如下。

让第一个平面旋转确定为

，（15.11）

其中α1和β1是t的上对角线和次对角线元素。定义

，

并将旋转应用于t。左乘在第一行引入一个新的非零元素，相应地，右乘在第一列引入一个新的非零元素：



×××。

1  TG1=___×+×+____

GT×××，

×××。

××××年

其中+表示新的非零元素。接下来，我们确定（2,3）-平面上的旋转，该平面消灭新的非零，同时进一步引入新的非零：

×××。+

2  GT1 TG1B2=____×0×+0____

燃气轮机×××。

×××。

×××。

××

以一种类似的方式，我们“追逐膨胀”，直到我们

，

通过最后的旋转，我们可以使凸起归零，同时恢复三对角形状。

注意，只有在确定第一个旋转（15.11）时才使用换档。旋转仅适用于非位移三对角矩阵。由于隐式qr定理，定理15.15，这相当于命题15.13中给出的移位qr步。

15.4.2特征向量

计算对称矩阵特征值的QR算法（包括三对角形式的约简）只需计算特征值，就需要4n3/3次方波。计算特征向量矩阵的正交变换的累积，大约需要另一个9n3触发器。

如果所有n个特征值都需要，但只有少数特征向量需要，那么使用逆迭代（第15.2节）计算这些特征向量更便宜，计算出的特征值λ_i作为偏移：

（a−λ_ii）x（k）=x（k−1），k=1,2，…。

QR算法产生的特征值非常接近精确的特征值（见下文），因此通常只需要逆迭代的一步就可以得到一个非常好的特征向量，即使对特征向量的初始猜测是随机的。

从数值稳定性的角度来看，QR算法是理想的。存在一个正正交矩阵q和一个扰动，使得特征值d_的计算对角矩阵完全满足

qt（a+e）q=d_

其中μ是浮点系统的四舍五入单位。

然后，根据定理15.2，我们知道计算出的特征值λ_i与精确的特征值相差很小。

### 15.5计算SVD

由于矩阵A的奇异值是ata和aat的特征值平方，很明显，计算svd的问题可以用类似于对称特征值问题的算法来解决。然而，重要的是避免形成矩阵ata和aat，因为这将导致信息丢失（参见第54页的最小二乘法示例）。

假设a为m×n，m≥n，计算稠密矩阵a的SVD的第一步是通过户主从左到右的变换将其简化为上双对角形式。

（15.12）

有关此减少的说明，请参见第7.2.1节。因为我们在这个约简中使用了正交变换，所以矩阵b的奇异值与a相同。假设σ是a的奇异值，其奇异向量为u和v。那么av=σu等于

   

从（15.12）。


 

15.6.非对称特征值问题

很容易看出矩阵btb是三对角的。计算b的奇异值的选择方法是矩阵btb采用隐式移位的三对角qr算法，而不显式形成。

设a∈rm×n，式中m≥n，在6mn2+20n3触发器中可计算出薄SVD a=u1∑v t（参见第6.1节）。

### 15.6非对称特征值问题

如果我们对非对称矩阵执行与第15.3节中相同的步骤，那么由于非对称性，对角线上方的任何元素都不会归零。因此，最终结果是Hessenberg矩阵：

|      | ×   ×   ×0   零   零 | ×   ×   ×   ×0   零 | ×   ×   ×   ×   ×0 | ×   ×   ×   ×   ×   × | ×   ____   ×   ×   ×   × |
| ---- | -------------------- | ------------------- | ------------------ | --------------------- | ------------------------ |
|      |                      |                     |                    |                       |                          |

使用户主转换将Hessenberg形式简化为10n3/3触发器。

15.6.1非对称矩阵的QR算法

第15.4节中给出的三对角矩阵的“未定义”QR算法同样适用于Hessenberg矩阵，其结果是上三角矩阵，即schur分解中的r因子。为了提高效率，就像在对称情况下一样，算法的每个步骤中的qr分解都是使用平面旋转来计算的，但是这里的转换应用于更多的元素。

我们用一个小例子来说明这个过程。假设矩阵H∈R6×6为上Hessenberg，假设从右下角的2×2矩阵计算出威尔金森位移τ。为了简单起见，我们假设这种转变是真实的。表示h（0）：=h。h−τi中的第一个次对角元素（从顶部）通过（1,2）平面中从左侧旋转归零，然后通过（2,3）中的旋转归零。象征性地，

| ________9116;______×0×0   经过n-1步，我们得到一个上三角矩阵： | ×   ×   ×   × | ×   ×   ×   ×   × | ×   ×   ×   ×   ×   × | ×   ____   ×   ×   ×   × |
| ------------------------------------------------------------ | ------------- | ----------------- | --------------------- | ------------------------ |
|                                                              |               |                   |                       |                          |

   

然后，我们应用右旋，rg1······gn-1，即，我们从涉及前两列的转换开始。然后进行涉及第二列和第三列的旋转。两步之后的结果是

.

我们看到我们在从左到右的变换中引入的零被系统地填充了。经过n-1步后，我们

.

但是我们做了一个相似变换：当q=g1g2······································

h（1）=rq+τi=qt（h（0）−τi）q+τi=qth（0）q，（15.13）

我们知道h（1）与h（0）具有相同的特征值。

非对称QR算法的收敛性几乎与对称QR算法的收敛性相同[93，第2章]。

提案15.16。具有威尔金森位移的非对称QR算法向舒尔分解四次收敛。

正如在对称情况下，上述算法有许多改进；参见，例如[42，第7章]，[93，第2章]。特别是，人们通常使用隐式双移位来避免复杂的算术运算。

在给定特征值的情况下，选取的特征向量可以用上Hessenberg矩阵进行逆迭代计算，并将计算出的特征值作为位移。

### 15.7稀疏矩阵

在许多应用中，矩阵元素的一小部分是非零的。然后矩阵被称为稀疏矩阵。很常见的是

15.7.稀疏矩阵

矩阵元素不是零。

在稀疏矩阵特征值问题的数值求解中，通常采用迭代法。这是因为第15.3节中描述的紧凑形式的转换将完全破坏稀疏性，从而导致过度的存储需求。此外，将其简化为紧凑形式的计算复杂度往往过高。

在第15.2节和第15.8节中，我们描述了数值求解大型稀疏矩阵特征值（和奇异值）问题的几种方法。这里我们简要描述了一种存储稀疏矩阵的可能方法。

为了利用矩阵的稀疏性，只能存储非零元素。我们简要描述了一种稀疏矩阵的存储方案，即压缩行存储。

例15.17。让



0.6667 0 0 0.2887_

0 0.7071 0.4082 0.2887

A=。

0.3333 0 0.4082 0.2887__

0.6667 0 0 0 0

在压缩行存储中，非零项存储在一个称为val的向量中（我们对表中的元素进行四舍五入以节省此处的空间），以及等长向量colind中相应的列索引：

| 瓦尔   | 零点六七 | 零点二九 | 零点七一 | 零点四一 | 零点二九 | 零点三三 | 零点四一 | 零点二九 | 零点六七 |
| ------ | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 科林德 | 一       | 四       | 二       | 三       | 四       | 一       | 三       | 四       | 一       |
| 罗普特 | 一       | 三       | 六       | 九       | 十       |          |          |          |          |

向量rowptr指向val中每行第一个元素所占据的位置。

压缩行存储方案便于将y=ax相乘。rowptr向量中在val向量结束后指向（不存在）位置的额外条目用于简化y=ax的乘法代码。

​             

稀疏A的乘法y=ax

​             

函数y=ax（val、colind、rowptr、x）

%计算y=a*x，其中压缩后的行存储m=length（rowptr）-1；对于i=1:m

a=val（rowptr（i）：rowptr（i+1）-1）；y（i）=a*x（colind（rowptr（i）：rowptr（i+1）-1））；

端部Y=Y'；

​             


 

可以看出，压缩行存储对于y=atz的乘法是不方便的。然而，有一种类似的压缩列存储方案，自然非常适合这种情况。

稀疏矩阵的压缩行（列）存储与FORTRAN和C等编程语言有关，程序员必须显式处理稀疏存储[27]。matlab有一个内置的稀疏矩阵存储方案，矩阵操作过载。例如，对于稀疏矩阵A，matlab语句y=a*x实现稀疏矩阵向量乘法，并且matlab在内部执行类似于上面的代码。

在特定的应用中，根据矩阵的结构，不同的稀疏矩阵存储方案会影响矩阵运算的性能。在[39]中，比较了用于信息检索的稀疏矩阵算法。

### 15.8 Arnoldi和Lanczos方法

QR方法可以用来计算中等尺寸矩阵的特征值和奇异值分解。（中型矩阵的大小取决于可用的计算能力。）通常在数据挖掘和模式识别中，矩阵非常大且稀疏。然而，稀疏矩阵的特征值、奇异值和舒尔分解通常是密集的：几乎所有元素都是非零的。

例15.18。考试中链接图矩阵的舒尔分解-

例1.3，

，

在matlab中计算得出：【u，r】=schur（a），结果如下：

U =

-0.0000-0.4680-0.0722-0.0530 0.8792-0.0000-0.0000-0.4680-0.0722-0.3576-0.2766-0.7559-0.5394 0.0161 0.3910 0.6378 0.0791-0.3780-0.1434-0.6458-0.3765 0.3934-0.3509 0.3780

-0.3960-0.2741 0.6232-0.4708-0.1231 0.3780

-0.7292 0.2639-0.5537-0.2934 0.0773-0.0000

r＝

| 零点九二零七 | 零点二二三九 | -0.2840个    | 零点零一四八 | -0.1078个 | 零点三三三四 |
| ------------ | ------------ | ------------ | ------------ | --------- | ------------ |
| 零           | 零点三三三三 | 零点一四九五 | 零点三七四六 | -0.3139个 | 零点零三七一 |
| 零           | 零           | -0.6361个    | -0.5327个    | -0.0181个 | -0.0960      |
| 零           | 零           | 零           | -0.3333个    | -0.1850年 | 零点一七五一 |
| 零           | 零           | 零           | 零           | -0.2846个 | -0.2642个    |
| 零           | 零           | 零           | 零           | 零        | 零           |

我们发现，正交矩阵的几乎所有元素都是非零的。

因此，由于存储要求变得禁止，使用QR方法通常是不可能的。相反，我们使用的方法不转换矩阵本身，而是将其用作运算符，即计算矩阵向量积y=ax。我们已经在第15.2节中描述了一种这样的方法，即功率法，可以用来计算最大特征值和相应的特征向量。本质上，在幂法中，我们计算一个向量序列，ax0，a2x0，a3x0，…，它向特征向量收敛。然而，一旦我们计算出一个新的功率，即，我们已经从yk 1=ak-1X到yk=akx，我们就扔掉yk-1和所有的信息。

包含在特征向量的早期近似中。

Krylov子空间方法的思想是使用矢量X0、Ax0、A2X0、…、AK−1的序列中的信息，这些信息组织在子空间中，即Krylov子空间，

kk（a，x0）=span x0，ax0，a2x0，…，ak−1x0，

从这个子空间中提取尽可能好的特征向量近似值。在第7章中，我们已经描述了Lanczos双标准化方法，这是一种Krylov子空间方法，可用于求解近似最小二乘问题。在第15.8.3节中，我们将证明它也可用于计算矩阵的某些奇异值和向量的近似值。但首先，我们提出了阿诺迪方法及其在计算大稀疏矩阵的部分舒尔分解问题中的应用。

15.8.1 Arnoldi方法和Schur分解

计算舒尔分解（定理15.5），假设a∈rn×n是大的、稀疏的、非对称的，并且我们希望toa=urut，其中u是或-

T形和R形是上三角形。我们对Arnoldi方法的推导将类似于lgk双标准化方法的第7章。因此，我们将从正交相似度约简到上赫森堡形式（这里n=6）：t______

×0×x×x×x

V av=H=0×××××××××（15.14）

零

0 0 0×0×X×X

0 0 0

原则上，这可以使用第15.3节中的户主转换来计算，但是由于a是稀疏的，这将导致填充零元素。相反，我们将展示V和H列可以以递归的方式计算，只使用矩阵向量积（就像在lgk双向化方法中一样）。在表格中重写（15.14）

   

一列一列地读，我们发现第一列是

av1=h11v1+h21v2，

它可以写在表格里

h21v2=av1−h11v1。

因此，因为v1和v2是正交的，所以h21是根据v2具有欧几里德长度1的要求确定的。同样地，（15.15）–（15.16）的第j列是

，

可以写的

（15.17）

现在，有了v1，v2，…，vj，我们可以从（15.17）计算vj+1，如果我们规定它与前面的向量是正交的。这给出了方程

hij=vitavj，i=1,2，…，j.

元素hj+1，j是根据vj+1的长度为1的要求得到的。

因此，我们可以使用以下递归计算v和h的列：

​             

#### 阿诺迪法

​             

1。起始向量v1，满足2。对于j=1,2，…

.

#### 三。结束

​             

显然，在步骤j中只需要一个矩阵向量积avj。

对于一个大型稀疏矩阵来说，在递归中执行许多步骤是不可能的，主要是出于存储的原因。假设已经执行了k个步骤，其中，和定义

.

现在我们可以用矩阵形式编写递归的前k步：

，（15.18）

哪里。这叫做阿诺迪分解。

在递归的k步之后，我们执行了k矩阵向量乘法。下面的命题表明，我们保留了这些步骤中产生的所有信息（与幂法相比）。

提案15.19。向量v1，v2，…，vk是krylov子空间k（a，v1）=span v1，av1，…，ak−1v1中的正交基。

证据。矢量的正交性通过构造（或直接计算）来验证。第二部分可以通过归纳法加以证明。

现在的问题是，我们如何能从krylov子空间近似特征值和特征向量。注意，如果zk是一个特征空间（见（15.4）），那么对于一些矩阵m∈Rk×k，我们将得到azk=zkm。因此，为了观察vk偏离特征空间的程度，我们可以检查对于一些矩阵m，剩余的avk−vkm有多大。幸运的是，有一个选择最优m的方法任何给定的VK。

定理15.20。设vk∈rn×k有正态列，并定义r（m）=avk−vkm，其中m∈rk×k。

   

解决方案m=vktavk。

证据。参见，例如[93，定理4.2.6]。

从Arnoldi分解（15.18），我们立即得到最佳MA-

特里克斯

m=vkt（vkhk+hk+1，kvk+1etk）=hk，

因为vk+1与前面的向量是正交的。根据阿诺迪分解，最佳残差由下式给出：

，

所以剩余范数在Arnoldi递归中是免费的。

假设vk是一个足够好的特征空间近似值，我们如何计算一个近似的部分schur分解auk=ukrk？让

是的舒尔分解，我们得到了

.

得出的特征值是A特征值的近似值。

例15.21。我们使用幂法和Arnoldi法计算了例15.10中定义的矩阵A100的最大特征值。图15.3给出了特征值近似值的误差。结果表明，Krylov子空间的特征值信息比幂法中唯一的向量所携带的特征值信息多得多。

上述基本Arnoldi方法有两个问题，这两个问题都可以有效地解决：

•在精确算法中，VJ向量是正交的，但在浮点算法中，正交性随着迭代的进行而丢失。通过明确地重新调整向量的方向性来修复正交性。这可以在算法的每个步骤中完成，也可以在检测到非正交性时选择性地完成。•工作量和存储需求随着迭代的进行而增加，在计算出足够好的近似值之前，可能会耗尽内存。这可以通过重启Arnoldi来解决。

零

​                                                     



​     

​     



​     

​     



​     

​     



​     

​     

​     

​     





​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     





​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     





​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     



​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     

​     











图15.3.计算A100最大特征值的幂和Arnoldi方法。功率法（虚线）和阿诺迪法（虚线）特征值近似的相对误差。

程序。本文发展了一种方法，在给定尺寸k的Arnoldi分解的情况下，将其简化为较小尺寸k0的Arnoldi分解，并在这种简化中清除不需要的特征值。这个隐式重启的arnoldi方法[64]已经在matlab函数eigs中实现。

15.8.2 Lanczos三对角化

如果将Arnoldi程序应用于对称矩阵A，则由于对称性，上Hessenberg矩阵hk变为三对角矩阵。从A的正交三对角化（15.5）开始，我们可以得出一个更经济的对称算法版本，我们将其写成

.

通过识别左右两侧的J列并重新排列方程，我们得到

βjvj+1=avj−αjvj−βj−1vj−1，

我们可以把它用于方程a v=v t的递归重构，系数αj和βj是根据向量正交和归一化的要求确定的。下面我们给出了生成Lanczos分解的Lanczos三对角化方法的基本版本，

avk=vktk+βkvk+1etk，

其中t k由t的第一行和第三列k组成。

​             

#### 兰佐斯三对角化

​             

1。把β0=0和v0=0，选择一个起始向量v1，满足2。对于j=1,2，…

.

#### 三。结束

​             

同样，在递归矩阵中，a不被转换，但只用于矩阵向量乘法，并且在每次迭代中只需要计算一个矩阵向量积。这种基本的Lanczos三对角化程序与基本的Arnoldi程序有相同的缺陷，可以用同样的方法来解决问题。

matlab函数eigs检查矩阵是否对称，如果是这样，则使用隐式重新启动的lanczos三对角化方法。

15.8.3计算稀疏SVD

LGK Bidialogization方法最初是为计算SVD而制定的[41]。它可用于计算部分双向化（7.11）。

azk=pk+1bk+1，

其中bk+1为双向，zk、pk+1为正交。基于这种分解，奇异值和奇异向量的近似计算方法与前一节中的三对角化方法类似。事实上，可以证明（如[4，第6.3.3章]）LGK


 

15.9.软件

双对角化过程等价于将Lanczos三对角化应用于对称矩阵。

，（15.19）

使用特定的启动向量，因此可以应用隐式重新启动。

matlab函数svds实现了矩阵的Lanczos三对角化方法（15.19），隐式重启。

### 15.9软件

在许多计算领域，一个相当常见的错误是低估了开发软件的成本。因此，不利用现有的软件是非常不明智的，尤其是当它是由世界专家开发并免费提供时。

15.9.1拉帕克

lapack是一个线性代数包，可以从netlib访问和下载，网址为http://www.netlib.org/lapack/。

我们引用网页描述：

Lapack用Fortran 77编写，并提供求解联立线性方程组、线性方程组的最小二乘解、特征值问题和奇异值问题的例程。还提供了相关的矩阵分解（Lu、Cholesky、QR、SVD、Schur、广义Schur），以及相关的计算，如Schur分解的重新排序和估计条件数。密集矩阵和带状矩阵被处理，但不是一般稀疏矩阵。在所有领域，实矩阵和复矩阵都提供了类似的功能，包括单精度和双精度。

lapack例程的编写使得尽可能多的计算是通过调用基本线性代数子程序（blas）来执行的。许多现代高性能计算机都可以使用高效的机器专用BLAS实现。或者，用户可以下载Atlas以自动为体系结构生成优化的BLAS库。

在LAPACK的基础上建立了matlab中的基本稠密矩阵函数。

LAPACK（或LAPACK的转换/转换）的可选语言接口可在FORTRAN 95、C、C++和Java中使用。

scalapack是lapack的一个并行版本，也可以从netlib获得，网址为http://www.netlib.org/scalapack/。这个包是为消息传递并行计算机而设计的，可以在任何支持MPI的系统上使用。

15.9.2稀疏矩阵软件

如前所述，matlab中的特征值和奇异值函数基于lanczos和arnoldi方法，并隐式重启[64]。这些算法摘自http://www.caam.rice.edu/software/arpack/。

从网页：

该包被设计用来计算一般n乘n矩阵a的几个特征值和相应的特征向量。它最适合于大型稀疏或结构化矩阵a，其中结构化意味着矩阵向量积w←av需要n阶，而不是通常的n2浮点数。int操作。

本书[4]概述了特征值和奇异值计算的算法和软件。

有关密集和稀疏矩阵计算的其他软件，请访问http://www.netlib.org/linalg/。

15.9.3编程环境

我们在这本书中使用了matlab作为描述算法的工具。在其他商用软件系统中，我们要提到Mathematica和统计软件包，如SASR和SPSS，它们具有矩阵计算、数据和文本挖掘的功能。