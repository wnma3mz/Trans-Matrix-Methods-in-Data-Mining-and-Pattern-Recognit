第十章

手写数字分类

手写数字的计算机分类是模式识别中的一个标准问题。典型的应用是自动读取信封上的邮政编码。[62]对不同的算法进行了全面的回顾。

10.1手写数字和简单算法

在图10.1中，我们将在本章的示例中说明手写数字。

   

图10.1.来自美国邮政服务数据库的手写数字；参见，例如[47]。

我们将以三种不同但等效的格式处理这些数字：

\1.    为16×16灰度图像，如图10.1所示；

\2.    作为两个变量的函数，s=s（x，y），如图10.2所示；

\3.    作为r256中的向量。

在未知数字的分类中，我们需要计算到已知数字的距离。可以使用不同的距离度量，也许最自然的度量是欧几里得距离：将图像的列堆叠到

一百一十三

   

2 4 6 8 10 12 14 16 0 2 4 6

图10.2.作为两个变量的函数的数字。

矢量并在r256中将每个数字标识为矢量。然后定义距离函数

.

另一个距离函数是两个向量之间的余弦。

在手写数字分类的实际应用中，例如邮政编码读取，必须考虑硬件和实时因素。在这一章中，我们描述一个理想化的环境。问题如下：

给定一组人工分类的数字（训练集），对一组未知数字（测试集）进行分类。

在美国邮政服务数据库中，培训集包含7291个手写数字。这里我们将使用1707位数字的子集，在0和9之间相对平均分布。测试集有2007个数字。

如果我们把训练集的数字看作向量或点，那么可以合理地假设一类的所有数字在欧几里得256维向量空间中形成一组点。理想情况下，集群是完全分离的（否则对未知数字进行分类的任务将非常困难），集群之间的分离取决于训练数字写得有多好。

   

图10.3.训练集中所有数字的平均值（质心）。

在图10.3中，我们说明了训练集中数字的平均值（质心）。从图中我们可以看出大多数数字都写得很好。（如果有许多写得不好的数字，则平均值将非常分散。）这表明簇之间的分隔相当好。因此，计算每个未知数字到平均值的距离的简单分类算法似乎是相当准确的。

​             

### 一种简单的分类算法

​             

训练：给定手动分类训练集，计算所有10个班的平均值（质心）mi，i=0，…，9。

分类：对于测试集中的每个数字，如果mk是最接近的平均值，则将其分类为k。

​             

结果表明，对于我们的测试集，该算法的成功率在75%左右，这还不够好。这种性能相对较差的原因是，该算法不使用任何有关每类数字变化的信息。

10.2使用SVD基础进行分类

我们现在将描述一种分类算法，该算法基于使用SVD计算的正交基向量对每个数字类内的变化进行建模。这可以看作是基于降秩模型的最小二乘算法；参见第7章。

如果我们将图像视为16×16矩阵，那么数据是多维的；参见图10.4。将每幅图像的所有列叠加在一起可以得到一个矩阵。假设a∈rm×n，m=256，是由一类所有训练数字组成的矩阵，比如3。一个跨度的列是Rm的线性子空间。但是，不能期望这个子空间有大的维度，因为如果它有，那么不同类型数字的子空间就会相交（记住，我们考虑的是r256的子空间）。

现在的想法是用子空间的正交基对一类训练（和测试）数字集内的变化进行“建模”。可以使用SVD计算正交基，任何矩阵A都是秩1矩阵的和：

++···（10.1）

A中的每一列代表一个数字3的图像，因此左奇异向量ui是“3的图像空间”中的正交基。我们将左奇异向量称为“奇异图像”。从（10.1）开始，A的第j列等于

到

，

​               

​                            



















二百五十六

数字

图10.4.一个数字的图像是一个矩阵，一类图像的集合形成张量。在图的下半部分，每个数字（一种）都由矩阵中的一列表示。

我们看到，根据这个基础，图像j在a中的坐标是σivij。根据SVD的矩阵逼近性质（定理6.6和6.7），我们知道第一个奇异向量代表数据矩阵的“支配”方向。因此，如果我们将向量ui折叠成图像，我们期望第一个奇异向量看起来像3，并且下面的奇异图像应该表示围绕第一个奇异图像的训练集的主要变化。在图10.5中，我们说明了训练集3的奇异值和前三个奇异图像。在中间的图中，我们根据前三个奇异向量绘制了131位数字中每个数字的坐标。我们看到所有的数字都有第一个奇异图像的很大一部分（在0.05和0.1之间），事实上，这看起来非常像图10.3中3的平均值。然后我们看到坐标中第二个和第三个单数的变化很大。

图像。

SVD基础分类算法将基于以下假设：

\1.    每个数字（在训练集和测试集中）都有其自身类型的第一个奇异图像的特征。“少”的更确切意义应该在实验中研究。

\2.    根据前几个奇异图像展开，可以很好地区分不同类别的数字。

三

   

图10.5.奇异值（顶部）、前三个右奇异向量vi（中间）和前三个奇异图像（底部）中131个测试数字的坐标。

\3.    如果一个未知数字在一个特定的奇异图像基（即3的基）中可以比在其他类的基中更好地近似，那么该未知数字很可能是3。

因此，我们应该计算一个未知数字在10个不同的基数中的表示能力。这可以通过计算类型的最小二乘问题中的剩余向量来实现。

，

其中z表示未知数字，ui表示奇异图像。我们可以

   

图10.6.所有试验3（顶部）和7（底部）在所有基础上的相对残差。每个类使用10个基向量。

把这个问题写在表格里

，

哪里。由于UK列是正交的，用α=UKTZ求出了该问题的解，最小二乘问题的残差向量范数为

，（10.2）即未知数字在与跨度正交的子空间上的投影范数（UK）。

为了证明上述假设是合理的，我们在图10.6中说明了所有测试3和7在所有10个基础上的相对剩余范数。




图10.7.未知数字（尼斯3）和近似使用1，3，5，7和9项在3基（顶部）。相对残差最小二乘问题（下）。

在这两个数字中，每个未知数字都有一条曲线，自然不可能看到单独的曲线。然而，我们可以看到，大多数的测试3和7是根据他们自己的基础最好的近似。这些图表还提供了关于哪些分类错误比其他分类错误更可能发生的信息。（例如，3’s和5’s是相似的，而3’s和4’s是完全不同的；当然，这只证实了我们已经知道的。）

还有一个有趣的现象，那就是残差是如何依赖于基数中的项数的。在图10.7中，我们用3基图像的不同数目来说明一个写得很好的3的近似值。在图10.8和10.9中，我们给出了3基中丑陋的3和5基中漂亮的3的近似值。

从图10.7和10.9中，我们可以看到nice 3在3-基中的相对残差比5-基中的相对残差小得多。我们还从图10.8中看到，丑陋的3在3个基础上没有很好地表示。因此，自然地，如果数字绘制得很糟糕，那么我们就不能期望得到基于SVD基的清晰分类。

基于支持向量机扩展模型，可以设计出几种分类算法。下面我们给出一个简单的变量。

图10.8.未知数字（丑陋的3）和近似值，使用1、3、5、7和9项作为3基数（顶部）。最小二乘问题中的相对残差

（底部）。

​             

### 一种SVD基分类算法

​             

训练：对于已知数字的训练集，计算每种数字的SVD。

分类：对于给定的测试数字，计算其在所有10个碱基中的相对残差。如果一个残差明显小于所有其他残差，则按此分类。否则放弃。

​             

该算法的工作总结如下：

训练：计算10个M2×NI矩阵的SVD。

每个数字都是m×m的数字化图像。ni：训练位数i。

测试：计算10个最小二乘残差（10.2）。

图10.9.未知数字（尼斯3）和近似使用1，3，5，7和9项在5个基础（顶部）。最小二乘问题中的相对残差

（底部）。

表10.1.将分类作为基础图像数量的函数进行更正（针对每个类）。

| #基础图像   | 一   | 二     | 四   | 六       | 八     | 十     |
| ----------- | ---- | ------ | ---- | -------- | ------ | ------ |
| 正确率（%） | 八十 | 八十六 | 九十 | 九十点五 | 九十二 | 九十三 |

因此测试阶段比较快，该算法适合于实时计算。该算法与simca方法有关[89]。

接下来，我们给出一些（来自[82]）美国邮政服务数据库的测试结果，这里有7291个培训数字和2007个测试数字[47]。在表10.1中，我们给出了分类结果，作为每类基础图像数量的函数。

即使与仅使用形心图像的方法相比，性能有了非常显著的改善，但由于最佳算法达到97%左右的正确分类，结果仍然不够好。培训和测试包含一些很难分类的数字；我们在图10.10中给出了一些示例。这样写得不好的数字很难自动处理。




二

四

六

八

十

十二

十四

十六

2 4 6 8 10 12 14 16 2 4 6 8 10 12 14 14 2 4 6 8 10 12 14 16 2 6 8 10 12 14 16

图10.10.美国邮政数据库中的丑陋数字。

​                                                                                                                                                                                                                                                                                             

图10.11.数字（左）和可接受的转换（右）。从左到右按列排列，数字（1）用一支更细、更粗的笔书写，（2）对角拉伸，（3）垂直压缩和拉长，以及（4）旋转。

10.3切线距离

一个好的分类算法应该能够对写得相当好但在欧几里得距离上仍与理想数字有很大偏差的未知数字进行分类。有些偏差是人类很容易处理的，而且是很常见和可以接受的。我们在图10.11中说明了一些这样的变化。这种转换对人类读者来说并不困难，理想情况下，在自动数字识别中，它们应该非常容易处理。[86，87]中描述了在小的此类变换下不变的距离测量，即切线距离。

16×16图像可以解释为r256中的点。设p为图像中的固定模式。我们首先考虑只允许一个转换的情况，比如说，在X方向转换模式（数字）。这种转换可以被认为是沿着r256中的曲线移动模式。将曲线参数化为实参数α，使曲线由s（p，α）给出，并以s（p，0）=p的方式给出。一般来说，曲线是非线性的，可以用泰勒展开式中的前两项来近似。

   

其中0）是r256中的向量。通过在0附近稍微改变α，我们沿着曲线上点P的切线做一个小的图案移动。假设我们有另一个模式e，近似于：

s（e，α）≈e+teα。

   

图10.12.点P和E之间的距离，以及切线距离。

因为我们在允许的情况下考虑沿着曲线的小运动，所以这样的小运动不应影响距离函数。因此，理想情况下，我们希望将p和e之间的紧密性度量定义为两条曲线之间的最近距离；见图10.12（参见[87]）。

然而，由于一般我们不能计算曲线之间的距离，我们可以使用一阶近似值，并计算点P和E中两条切线之间的最近距离。因此，我们将沿着它们各自的切线独立移动图案，直到找到最远的距离。如果我们用通常的欧几里得范数来测量这个距离，我们就求解最小二乘问题。-

莱姆

.

现在考虑一下这样的情况，当我们允许沿着l在r256中的不同曲线移动模式p时，用α=（α1···αl）t参数化。这相当于在r256中的l维表面（流形）上移动模式。假设我们有两个模式，p和e，每个模式都允许在其允许转换的表面上移动。理想情况下，我们希望找到曲面之间最近的距离，但是，由于这是不可能计算的，我们现在定义一个距离测量，在这里我们计算点p和e中曲面的两个相切平面之间的距离。

如前所述，切线平面由函数s（p，α）的泰勒展开式中的前两项给出：

   

其中tp是矩阵

，

导数都在点（p，0）中进行了计算。

因此，点P和点E之间的切线距离被定义为最小二乘问题中可能的最小残差，

.

可以解决最小二乘问题，例如，使用的SVD。

请注意，我们对解决方案本身不感兴趣，只对残差的范数感兴趣。把最小二乘问题写在表格中

.

如果我们使用QR分解

   

残差的范数由下式给出

.

当矩阵A碰巧没有完整的列秩时，可以使用SVD轻松处理；参见第6.7节。当两个模式接近时，相切矩阵的列几乎成线性依赖关系的概率很高。

这个距离函数最重要的特性是它在切线平面上图案的运动下是不变的。例如，如果我们在一个图案的X方向做一个小的平移，那么用这个度量，它移动的距离等于零。

### 10.3.1改造

在这里，我们把图像模式看作是两个变量的函数，p=p（x，y），我们证明了每个变换的导数可以表示为微分算子，它是导数px=dxdp和

   




图10.13.一个模式，它的x-导数和该模式的x-翻译。

翻译。最简单的转换是模式在x方向上由αx转换，即：

s（p，αx）（x，y）=p（x+αx，y）。

显然，使用链式法则，

.

在图10.13中，我们给出了一个模式及其x-导数。然后我们证明，通过添加一个小的导数倍数，模式可以被转换为左和右。

类似地，对于y-翻译，我们得到

.

旋转。用点（x，y）中的p值替换点（x，y）中的p值，以此角度αr旋转图案。

.

因此我们定义了函数

s（p，αr）（x，y）=p（x cosαr+y sinαr，−xsinαr+y cosαr），

我们得到了导数

.

设置αr=0，我们有

，

其中衍生产品的评估值为（x，y）。

图10.14给出了旋转变换的示例。

图10.14.一个图案，它的旋转导数，以及图案的旋转。

   

图10.15.模式及其缩放导数，以及模式的“向上缩放”。

缩放。通过定义

s（p，αs）（x，y）=p（（1+αs）x，（1+αs）y），

我们得到了导数

.

比例转换如图10.15所示。

通过定义

s（p，αp）（x，y）=p（（1+αp）x，（1-αp）y），

我们可以把图案拉伸到与轴线平行的地方。衍生产品是

.

在图10.16中，我们展示了平行双曲线变换。

对角双曲变换。通过定义

s（p，αh）（x，y）=p（x+αhy，y+αhx）

我们可以沿着对角线拉伸图案。衍生产品是

.

在图10.17中，我们展示了对角双曲变换。

图10.16.一个图案，它的平行双曲线导数和两个拉伸图案。

   

图10.17.一个图案，它的对角双曲导数，和两个拉伸图案。

   

图10.18.一个图案，它的增厚衍生物，一个更薄的图案，和一个更厚的图案。

加厚。使用类似技术可以使图案变薄或变厚；有关详细信息，请参见[87]。“增厚”衍生物是

（px）2+（py）2.

增稠和减薄如图10.18所示。

​             

切线距离分类算法

​             

训练：对于训练集中的每个数字，计算其切线矩阵tp。

分类：对于每个测试数字，

•    计算其正切矩阵；

•    计算所有训练位数的切线距离，并将测试位数分类为最近的训练位数。

​             




虽然该算法在分类性能方面相当好（美国邮政服务数据库[82]的正确分类率为96.9%），但它非常昂贵，因为每个测试数字都要与所有训练数字进行比较。为了具有竞争力，它必须与其他一些减少切线距离比较数量的算法相结合。

在本章结尾，我们指出有必要以不同的方式对数字进行预处理，以增强分类；见[62]。例如，如果图像平滑（与高斯核卷积）会提高性能[87]。在[82]中，导数px和py通过有限差分进行数值计算。

